%% Import data from text file.
% Script for importing data from the following text file:
%

%    D:\Spring 2015\Machine Learning\Project2\data\train.label
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/03/13 22:06:51

%% Initialize variables.
filename = 'D:\Spring 2015\Machine Learning\Project2\data\train.label';
delimiter = '';


%% Format string for each line of text:
%   column1: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
train_label = dataArray{:, 1};

%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;

%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\Spring 2015\Machine Learning\Project2\data\train.data
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/03/14 03:04:06

%% Initialize variables.
filename = 'D:\Spring 2015\Machine Learning\Project2\data\train.data';
delimiter = ' ';

%% Format string for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
doc_id = dataArray{:, 1};
word_id = dataArray{:, 2};
word_count = dataArray{:, 3};
matrix=[doc_id word_id word_count]; % Moving all the variables to a matrix

%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;

%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\Spring 2015\Machine Learning\Project2\data\vocabulary.txt
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/03/14 04:11:43

%% Initialize variables.
filename = 'D:\Spring 2015\Machine Learning\Project2\data\vocabulary.txt';
delimiter = '';

%% Format string for each line of text:
%   column1: text (%s)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
vocabulary = dataArray{:, 1};


%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;

%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\Spring 2015\Machine Learning\Project2\data\test.data
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/03/14 21:33:28

%% Initialize variables.
filename = 'D:\Spring 2015\Machine Learning\Project2\data\test.data';
delimiter = ' ';

%% Format string for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
doc_id_test = dataArray{:, 1};
word_id_test = dataArray{:, 2};
word_count_test = dataArray{:, 3};
test_matrix = [doc_id_test word_id_test word_count_test]; % Moving all the variables to a matrix

%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;
%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\Spring 2015\Machine Learning\Project2\data\test.label
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/03/15 00:08:59

%% Initialize variables.
filename = 'D:\Spring 2015\Machine Learning\Project2\data\test.label';
delimiter = '';

%% Format string for each line of text:
%   column1: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
test_label = dataArray{:, 1};


%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;

[row_train_label,column_train_label]=size(train_label);  % Computing the row and column of the train label with size function
k=1;                                                     % Intializing the varible
doc_prob=zeros(20,1);                                    % Intializing the doc_matrix matrix with values zero
for i=1:1:row_train_label                                
    if(train_label(i)==k)                                % Comparing the train lable content with the value k
        doc_prob(k)=doc_prob(k)+1;                       % Updating the count of Value k occurance using k as index 
    else
        k=k+1;                                           % Incrementing value of k for comparing with next integer after the current K value
        doc_prob(k)=1;                                   % Initialising the document count to 1 since for the first Document count we will miss count
                                                         % in the "if condition" in the above loop
    end
end

doc_prob=doc_prob/row_train_label;                       % Computing the probablitity of the categories by dividing with the total number of documents
[row_vocabulary,column_vocabulary]=size(vocabulary);     % Computing the row and column of the vocabulary with size function
count_matrix=zeros(20,row_vocabulary);                   % Intializing the count_matrix matrix with values zero
[row_matrix,column_matrix]=size(matrix);                 % Computing the row and column of the matrix(train data content) with size function
for i=1:1:row_matrix
    count_matrix(train_label(matrix(i,1),1),matrix(i,2))=matrix(i,3)+count_matrix(train_label(matrix(i,1),1),matrix(i,2));  
                                                         % Updating the count_matrix which constitutes of segmenting the document IDS from each
                                                         % category to the corresponding group(category) using the train_label content as the row value.
end
[row_count_matrix,column_count_matrix]=size(count_matrix); % Computing the row and column of the train label with size function
vocabulary_total=61188;                                  % Hard coding the vocabulary_total with the vocabulary lenght we have

beta=1/vocabulary_total;                                 % computing the "beta" value as inverse of vocabulary_total

%beta_count=linspace(.0001,1,1000);                      % Dividing the values between .0001-1 in to 1000 values and storing in beta_count array
%for j=1:1:length(beta_count)                            % for loop initializing from 1 to 1000 values with 1 increment
%    beta=beta_count(j);                                 % moving the beta_count value of jth index to beta variable


for i=1:1:row_count_matrix                               % for loop initializing from 1 to the row value of count matrix with 1 incrementation
total_count(i,1)=sum(count_matrix(i,:));                 % Updating the total_count array with sumation of the whole row values of count_matrix
conditional_probability_matrix(i,:)=(count_matrix(i,:)+ beta)./(total_count(i,1)+ beta*vocabulary_total);
                                                         % Calcualting the conditional probability matrix (MAP) by usng the formula
end

row_test_data = 7505;                                    % Hard coding the row_test_data with the test label count 
column_test_data = 61188;                                % Hard coding the column_test_data with the voculabulary count 
test_count_matrix=zeros(row_test_data,column_test_data); % Intializing the test_count_matrix matrix with values zero
for i=1:1:967874                                         % for loop to access the data in test data document
test_count_matrix(test_matrix(i,1),test_matrix(i,2))=test_count_matrix(test_matrix(i,1),test_matrix(i,2))+ test_matrix(i,3);
                                                         % Updating the test_count_matrix matrix with category value, Document id from the 
                                                         % test data document with the count value present in test.data
end
ynew=test_count_matrix*log2(transpose(conditional_probability_matrix)); % computing the product of test_count_matrix with the log 2 base of MAP
doc_prob_transpose=log2(transpose(doc_prob));            % tranposing the document probability values to match the dimensions of the ynew matrix
correct=0;                                               % Initializing the correct variable count to "0" for accuracy calculation
wrong=0;                                                 % Initializing the wrong variable count to "0" for accuracy calculation
for i=1:1:7505
yfinal(i,:)=ynew(i,:)+doc_prob_transpose;                % Computing the yfinal for classification by adding the documnent probability for each 
                                                         % and every row of the ynew variable
[category(i,1),category(i,2)]=find(yfinal(i,:)==max(yfinal(i,:))); 
                                                         % Categorizing the words with the index of the yfinal which has the maximum value 
  if(category(i,2) == test_label(i,1))                   % Comparing the document catageory of predicted value to the actual test data value for accuracy calculation
    correct=correct+1;                                   % Incrementing the correct variable when the "if condition" is satisfied
  else 
    wrong=wrong+1;                                       % Incrementing the wrong variable when the "if condition" fails
   end
end
%accuracy(j)=correct*100/(correct+wrong);                % Computing the accuracy percentage matrix for the 1000 beta values from .0001-1
accuracy=correct*100/(correct+wrong);                    % Computing the accuracy percentage when beta=1/vocabulary length
%end
%semilogx(beta_count,accuracy);                          % semilog plot for beta values and accuracy obtained with different beta values
[confusion_matrix, order_confusion]= confusionmat(test_label,category(:,2));
                                                         % Computing the confusion matrix with the predicted and actual document category values
for i=1:1:20
   confusion_matrix_percentage(i,:)=confusion_matrix(i,:)*100/sum(confusion_matrix(i,:));
                                                         % Computing the misclassification percetage for the confusion matrix.
end
for i=1:1:61188
ranking(i)=max(conditional_probability_matrix(:,i)/sum(conditional_probability_matrix(:,i)));
                                                         % Ranking the words by using the conditional probablity values that is dividing the 
                                                         % max of probable value to the sum of all the conditional probabilities of the word
end 
[ranking ranking_index]=sort(ranking,'descend');         % sorting of the values of the ranking array with sort function in descending order and 
                                                         % returning the index value of the sorted list
for i=1:1:100
    high_frequeny_words(i)=vocabulary(ranking_index(i)); % storing the top 100 words by using the index of sorted list and retriving the word for the 
                                                         % vocabulary list with the index
end